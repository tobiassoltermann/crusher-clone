var RoomColors = {
  'blue': 0,
  'green': 1,
  'purple': 2,
  'red': 3,
  'yellow': 4
};
var DiamondColors = {
  'blue': 0,
  'green': 1,
  'purple': 2,
  'red': 3,
  'yellow': 4
};
var MonsterColors = {
  'blue': 0,
  'green': 1,
  'purple': 2,
  'red': 3,
  'yellow': 4
};

var StartPositions = {
  'TOP': {x: 9, y: 0},
  'BOTTOM': {x: 9, y: 12},
  'LEFT': {x: 0, y: 6},
  'RIGHT': {x: 18, y: 6}
}

Position = function(x, y) {
  this.x = x;
  this.y = y;
}
Position.prototype.constructor = Position;

Monster = function(x, y) {
  this.position = new Position(x, y);
}

Monster.prototype.constructor = Monster;

Room = function(engine) {
  this.engine = engine;
  this.elems = Create2DArray(this.width, this.height);
  this.brickColor = getRandomItemKey(RoomColors);
  this.diamondColor = getRandomItemKey(DiamondColors);
  this.monsterColor = getRandomItemKey(MonsterColors);
}
Room.prototype.constructor = Room;
Room.prototype.width = 19;
Room.prototype.height = 13;

Room.prototype.getObject = function(x, y) {
  return elems[x][y];
}

Room.prototype.generate = function() {
  this.elems = this.engine.roomGenerator.generate();
}

Room.prototype.getRandomEmptyPosition = function() {
  var possibleResult = [];
  var lines = this.elems;
  for (var crtX = 0; crtX < lines.length; crtX++)
  {
    var crtLine = lines[crtX];
    for (var crtY = 0; crtY < crtLine.length; crtY++)
    {
      var crtElement = crtLine[crtY];
      if(crtElement == "empty")
      {
        possibleResult.push({x: crtX, y: crtY});
      }
    }
  }

  var randomIndex = randomNumber(0, possibleResult.length-1);
  return possibleResult[randomIndex];
}

Room.prototype.onEnter = function() {
  this.monsters = [];
  for (var i = 0; i < this.engine.roomGenerator.numberOfMonsters; i++)
  {
      this.monsters.push({
        color: this.monsterColor,
        position: this.getRandomEmptyPosition()
      });
  }
}


RoomGenerator = function(paramObj) {
  if (paramObj)
  {
    this.params = paramObj;
  } else {
    this.params = { // Default probabilities:
      fixed: 0.2105, // 52 of 247
      color: 0.2469, // 61 of 247
      air: 0.0121, // 3 of 247
      diamond: 0.0242, // 6 of 247
      bomb: 0.0040, // 1 of 247
      empty: 0.5344 // 132 of 247
    }
  }
}
RoomGenerator.prototype.constructor = RoomGenerator;
RoomGenerator.prototype.width = 19;
RoomGenerator.prototype.height = 13;
RoomGenerator.prototype.numberOfMonsters = 3;
RoomGenerator.prototype.generate = function() {
  var drng = new DRNG();
  drng.addNumber('fixed', this.params.fixed);
  drng.addNumber('color', this.params.color);
  drng.addNumber('air', this.params.air);
  drng.addNumber('diamond', this.params.diamond);
  drng.addNumber('bomb', this.params.bomb);
  drng.addNumber('empty', this.params.empty);
  var room = Create2DArray(this.width, this.height);
  var lines = room;
  for (var crtX = 0; crtX < lines.length; crtX++)
  {
    var crtLine = lines[crtX];
    for (var crtY = 0; crtY < crtLine.length; crtY++)
    {
      room[crtX][crtY] = drng.getRandomNumber();
    }
  }
  return room;
}

Player = function(engine) {
  this.men = 5;
  this.oxygen = 150;
}

Engine = function(canvas) {
  console.log("engine");
  this.roomGenerator = new RoomGenerator();
  this.isReady = false;
  this.img = {};
  this.c = canvas;
  this.c2 = canvas.getContext('2d');

  this.rooms = {};
  for (i = 0; i < this.numberOfRooms; i++)
  {
    this.rooms[i] = new Room(this);
    this.rooms[i].generate();
  }

  this.crtRoom = 13;

  this.player = new Player(this);
  this.switchRoom(undefined, this.crtRoom);

  this.registerKeyHandlers();
  var _this = this;
  this.preloadImages(function() {
    setTimeout(
      function() {
        _this.tick();
      }
    , 100);
  });

}

Engine.prototype.playSound = function(name) {
  $('#snd_' + name )[0].play();
}

Engine.prototype.handleEvent = function(event) {
  switch (event) {
    case "UP":
      this.movePlayer({x: 0, y: -1});
      break;
    case "RIGHT":
      this.movePlayer({x: 1, y: 0});
      break;
    case "LEFT":
      this.movePlayer({x: -1, y: 0});
      break;
    case "DOWN":
      this.movePlayer({x: 0, y: 1});
      break;
  }
}
Engine.prototype.thisRoom = function() {
  return this.rooms[this.crtRoom];
}
Engine.prototype.getThisRoomTile = function(x, y) {
  try {
    return this.thisRoom().elems[x][y];
  } catch (exception) {
    return undefined;
  }
}
Engine.prototype.setThisRoomTile = function(x, y, value) {
  return this.thisRoom().elems[x][y] = value;
}

Engine.prototype.movePlayer = function(direction) {
  var newPos = {
    x: (this.player.position.x + direction.x),
    y: (this.player.position.y + direction.y)
  };
  var crtTile = this.getThisRoomTile(newPos.x,newPos.y);
  switch (crtTile) {
    case "empty":
      // We can move on an empty space.
      // TODO: Check if there's a monster!
      this.player.position = newPos;
      this.playSound("step");
      break;
    case "undefined":
      // We've hit the border. We cannot move!
      // TODO: Exceptions for room switch.
      console.log("Border.");
      break;
    case "fixed":
      // Do nothing. We cannot move!
      console.log("Fixed object.");
      break;
    case "color":
      // Okay, we're hitting a color block. Is there one behind or border?
      var behindPos = {
        x: (newPos.x + direction.x),
        y: (newPos.y + direction.y)
      };

      if (this.getThisRoomTile(behindPos.x, behindPos.y) == "empty") {
        // If and only if the space behind is empty, we can move the block by one
        this.setThisRoomTile(behindPos.x,behindPos.y,"color");
        this.setThisRoomTile(newPos.x,newPos.y,"empty");
        this.player.position = newPos;
        this.playSound("step");
      } else {
        // Otherwise we can't.
        console.log("Cannot move the block.");
      }

      break;
    case "air":
    case "diamond":
    case "bomb":
      console.log('Take item.');
      this.setThisRoomTile(newPos.x,newPos.y,"empty");
      this.player.position = newPos;
      this.playSound(crtTile);
  }

  this.draw();
}

Engine.prototype.registerKeyHandlers = function() {
  this.keyListener = new window.keypress.Listener();
  var _this = this;
  var handleUp = function() {_this.handleEvent('UP'); }
  var handleDown = function() { _this.handleEvent('DOWN'); }
  var handleRight = function() {_this.handleEvent('RIGHT'); }
  var handleLeft = function() { _this.handleEvent('LEFT'); }

  this.keyListener.simple_combo("w", handleUp);
  this.keyListener.simple_combo("up", handleUp);

  this.keyListener.simple_combo("s", handleDown);
  this.keyListener.simple_combo("down", handleDown)

  this.keyListener.simple_combo("a", handleLeft);
  this.keyListener.simple_combo("left", handleLeft)

  this.keyListener.simple_combo("d", handleRight);
  this.keyListener.simple_combo("right", handleRight);
}
Engine.prototype.switchRoom = function(oldRoom, newRoom) {
  this.crtRoom = newRoom;
  if (oldRoom)
  {
    difference = newRoom - oldRoom;
    switch (difference)
    {
      case this.mapWidth:
        // We went down
        this.player.position = StartPositions["TOP"];
      break;
      case -(this.mapWidth):
        // We went up
        this.player.position = StartPositions["BOTTOM"];
      break;
      case 1:
        // We went right
        this.player.position = StartPositions["LEFT"];
      break;
      case -1:
        // We went left
        this.player.position = StartPositions["RIGHT"];
      break;
    }
  } else {
    this.player.position = getRandomItemValue(StartPositions);
  }
  console.log('Random player pos:', this.player.position);
  this.rooms[this.crtRoom].onEnter();
  this.setThisRoomTile(this.player.position.x, this.player.position.y,"empty");
  $("#playerPos").text(this.player.position.x + ", " + this.player.position.y);
}


Engine.prototype.preloadImages = function(callback) {
  var toLoad = [
    "brick_blue",
    "brick_green",
    "brick_purple",
    "brick_red",
    "brick_yellow",
    "diamond_blue",
    "diamond_green",
    "diamond_purple",
    "diamond_red",
    "diamond_yellow",
    "brick_fixed",
    "bomb",
    "eve",
    "man_happy",
    "man_sad",
    "question",
    "mrx",
    "map",
    "o2",
    "monster_blue",
    "monster_red",
    "monster_green",
    "monster_purple",
    "monster_yellow",
    "safe",
    "ted"
  ];

  this.img = new Array()
  _this = this;
  new preLoader(toLoad.map(this.addPath), {
    onProgress: function(img, imageEl, length) {
      var interm = img.substring("/rsc/".length);
      var toLoadItem = interm.substring(0, interm.length- (".png".length));
      _this.img[toLoadItem] = imageEl;
    },
    onComplete: function(loaded, errors) {
      this.isReady= true;
      callback();
    }
  });
}


Engine.prototype.leftOffset = 30;
Engine.prototype.rightOffset = 30;
Engine.prototype.topOffset = 30;
Engine.prototype.bottomOffset = 30;
Engine.prototype.numberOfRooms = 24;
Engine.prototype.mapWidth = 5;

Engine.prototype.fieldSize = 32;
Engine.prototype.addPath = function (current) {
  return "/rsc/"  + current + ".png";
}
Engine.prototype.constructor = Engine;

Engine.prototype.draw = function(){
  this.c2.fillStyle = "#000000";
  //this.c2.fillRect(0, 0, this.c.width, this.c.height);
  var crtRoom = this.rooms[this.crtRoom];

  var lines = crtRoom.elems;

  for (var crtX = 0; crtX < lines.length; crtX++)
  {
    var crtLine = lines[crtX];
    for (var crtY = 0; crtY < crtLine.length; crtY++)
    {
      var crtElement = crtLine[crtY];

      switch (crtElement) {
        case 'fixed':
          this.drawImage("brick_fixed", crtX, crtY);
          break;
        case 'color':
          this.drawImage("brick_" + crtRoom.brickColor, crtX, crtY);
          break;
        case 'air':
          this.drawImage("o2", crtX, crtY);
          break;
        case 'diamond':
          this.drawImage("diamond_" + crtRoom.diamondColor, crtX, crtY);
          break;
        case 'bomb':
          this.drawImage("bomb", crtX, crtY);
          break;
        case 'empty':
          this.c2.fillStyle = "#000000";
          this.c2.fillRect(this.leftOffset + Math.round(crtX * this.fieldSize), this.topOffset + crtY * this.fieldSize, Engine.prototype.fieldSize, Engine.prototype.fieldSize);
          break;
      }
    }
  }
  // ### DRAW BORDER ###
  this.c2.fillStyle = "#008080";
  // TOP
  this.c2.fillRect(0, 0, this.c.width / 2 - this.fieldSize / 2, this.fieldSize*.8);
  this.c2.fillRect(this.c.width / 2 + this.fieldSize / 2, 0, this.c.width / 2 - this.fieldSize / 2, this.fieldSize*.8);

  // BOTTOM
  this.c2.fillRect(0, this.c.height - (this.fieldSize*.8), this.c.width / 2 - this.fieldSize / 2, this.fieldSize*.8);
  this.c2.fillRect(this.c.width / 2 + this.fieldSize / 2, this.c.height - (this.fieldSize*.8), this.c.width / 2 - this.fieldSize / 2, this.fieldSize*.8);

  // LEFT
  this.c2.fillRect(0, 0, this.fieldSize*.8, this.c.height / 2 - this.fieldSize / 2);
  this.c2.fillRect(0, this.c.height / 2 + this.fieldSize / 2, this.fieldSize*.8, this.c.height / 2 - this.fieldSize / 2);

  // RIGHT
  this.c2.fillRect(this.c.width - (this.fieldSize*.8), 0, this.fieldSize*.8, this.c.height / 2 - this.fieldSize / 2);
  this.c2.fillRect(this.c.width - (this.fieldSize*.8), this.c.height / 2 + this.fieldSize / 2, this.fieldSize*.8, this.c.height / 2 - this.fieldSize / 2);

  // ### DRAW PLAYER ###
  this.drawImage("man_happy", this.player.position.x, this.player.position.y);
  $("#playerPos").text(this.player.position.x + ", " + this.player.position.y);

  // ### DRAW MONSTERS ###
  for (var i = 0; i < this.thisRoom().monsters.length; i++)
  {
    var crtMonster = this.thisRoom().monsters[i];
    this.drawImage("monster_" + crtRoom.monsterColor, crtMonster.position.x, crtMonster.position.y);
  }
}
Engine.prototype.ready = function() {
  return this.isReady;
}

Engine.prototype.drawImage = function(image, posX, posY)
{
  var imageFull = this.img[image];
  try {
    this.c2.drawImage(imageFull, this.leftOffset + Math.round(posX * this.fieldSize), this.topOffset + posY * this.fieldSize, Engine.prototype.fieldSize, Engine.prototype.fieldSize);
  } catch (error) {

  }
}

Engine.prototype.tick = function(){
  this.draw();
}
